	Коллекции JAVA: Введение

Корневой тип данных это Object
Он считывается везде.
В него можно упаковывать данные 
и распаковывать обратно.

Упаковка - любой тип можно положить в 
переменную типа Object

Распаковка - преобразование 
Object-переменной в нужный тип данных

Иерархия - тип Object находится в самой
вершине иерархии типов данных. Так любой
тип будет ниже Object.

Благодаря типу Object мы можем запаковать
в одну коллекцию множество разных типов 
данных и int, string, double...
Потом просто проверять их с промощью 
цикла if  и присваивать им же те типы которые
за ними могут быть закреплены. 

(!) Приведение типов в этом цикле на 
сленге "Кастовать".

		Массивы

Какие бывают пробдемы при использовании
массивов?

Массив ограничен в своем размере.
Изменение размера массива мы делаем в 
ручную либо создаем новый массив который
будет больше. Либо придется писать 
отдельный метод который будет делать все
что описанно выше и это скажется на 
производительнсти нашей программы.

Возникают сложноси обработки информации
в оперативной памяти, происходит
много лишних действий.

		Коллекции

В онове всего стоит интерфейс Collection
это корневой интерфейс из которого исходят
все колекции.

От Collection наследуюется большая группа 
большая группа коллекций set, list и queue

Отдельно идут map

Часть из них рекомендуется к использованию
часть считается устаревшими но они 
продолжают работать ибо есть обратная 
совместимость.

		ArrayList

Обьявляестя
ArrayList list = new ArrayList ();

Подходит для работы с коллекцией, 
доступной только для чтения

в целом про всё что связанно с понятием List
к листам относят ArrayList, LinkedList, (Vector,
Stack являются устаревшими).

Если есть отдельный функционал для одной
коллекции то он есть и для другой. Может
быть разное поведение но если у вас есть 
метод который на пример добавляет 
элемент то он будет одинаково работать 
как на ArrayList так и на LinkedList.

List - это пронумированный набор элементов.
Тут пользователь имеет точный контроль
над тем где в списке вставляется каждый 
элемент.
- сохраняется порядок элементов
- по индексу пожно получить конкретный
элемент. Если нужно то прочитать, 
заменить или удалить элемент. Всё это
описывается конкретным функционалом.

	LinkedList

Представляет из себя двусвязный список, 
где каждый элемент структуры содержит 
ссылки на предыдущий и следующий 
элементы.

подходит для работы с коллекцией, 
допускающей различные модификации 
данных, такие как добавление и 
удаление.

(!) Разница между ArrayList и LinkedList в 
том что ArrayList реализует только список, 
а LinkedList реализует и список, и очередь.

LinkedList также часто используется в 
качестве очередей.

	Обобщения типов данных
	при работе в колекциями

(!) Есть возможность использовать обобщения
когда мы прописываем тип используемых
данных содержащихся в ArrayList. Указывается
в угловых скобках <>. В примере у нас 
обобение к формату Integer.

ArrayList<Integer> list = new ArrayList<Integer> ();

* Обобщение указываем с двух сторон с права
и слева от оператора присваивания.
Но можно и не писать справа от оператора
присваивания типа.

Если обобщения нет то процесс казания типов
данных усложниится в силу того что по 
умолячанию будет присвоен типо Object и из
него уже проверками будут распаковываться
нужные нам тип данных специальными 
методами. Это возьмет больше ресурсов в 
системе и займет больше времени.

Итого можно использовать как сырой тип
данных по умолчанию без типа, либо указать
явно тип данных с которым будет работать
ArrayList.

* Правильней писать с обобщением.

Функционал и комманды для коллекций:
- add(args) - добавление элемента
- get(pos) - возвращает элемент из списка по
указанной позиции
- indexOf(item) - первое вхождение -1
- lastIndexOf(item) - последнее вхожде-е или -1
- remove(pos) - удаление элемента на указанной
позиции и его возврат
- set(int pos, T item) - givtoftn значение item
элементу, который находится на позиции pos
- void sort(Comparator) - сортирует набор 
данных по правилу
- subList(int start, int end) - получение набора
данных от позиции start до end.
- clear() - очистка списка
- toString() - конвертация списка в строку
- Arrays.asList - преобразование массива
в список
- containsAll(col) - проверяет включение всех
элементов из col
- removeAll(col) - удаляет элементы, 
имеющиеся в col
- retainAll(col) - оставляет элементы 
имеющиеся в col
- toArray() - конвертация списка в массив
Object'ов
- toArray(type array) - конвертация списка
в массив type
- List.copyOf(col) - возвращает копию 
списка на основе имеющегося
- List.of(item1, item2,...) - возвращает 
неизменяемый список

	Итератор и для чего нужны
	итерируемые объекты

Итератор (от англ. iterator ― 
перечислитель) — интерфейс, 
предоставляющий доступ к элементам 
коллекции (массива или контейнера) 
и навигацию по ним.

Для перебора условной колекции юзаем 
следующий синтаксис:

пример:
for (тип данных имя переменной : имя
колекции) {
тело цикла или указание доп. условий
проверки через if
}

итератор позволяет перебирать объекты 
находщиеся в колекции, находить их
и обрабатывать.

(!) при работе с итератором не нужно 
пытаться удалять элемента или по 
нескольку раз этот элемент вызывать.
Иначе получим ошибку.

Итератор юзают для более гибкой работы
с данными.

Позволяют вызывающей стороне 
удалять элементы из базовой коллекции
во время итерации с четко определенной
семантикой.